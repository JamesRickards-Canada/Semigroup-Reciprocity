print("\n\nType '?semigroup' for help.\n\n");
parigp_version=version();
semigroup_library=strprintf("./libsemigroup-%d-%d.so", parigp_version[1], parigp_version[2]);

/*thin.c*/
  addhelp(semigroup,"Basic (semi)group methods:\n\tLRword, semigroupgrowth, semigroupmats.\n\nMissing numbers in orbits:\n\tsemigroup_missing, semigroup_missing_parabolic.\n\nLinear regression:\n\tOLS, OLS_nointercept, OLS_single, rsquared.");
  
  /*SECTION 1: BASIC (SEMI)GROUP METHODS*/
  install(LRword,"G",,semigroup_library);
  addhelp(LRword,"LRword(M): for M a SL(2, Z)^{>=0} hyperbolic matrix with positive entries, returns M as a word in L and R, where L=[1,1;0,1] and R=[1,0;1,1]. This is a Vecsmall with 0 representing L and 1 representing R. M must itself have entries that fit into the sice of a C long.");
  install(semigroupgrowth,"GD100,L,D1000,L,DGp");
  addhelp(semigroupgrowth,"semigroupgrowth(mats, {binsize=100}, {Nbins=1000}, {start=[1, 1]}): estimates the growth rate of the orbits of the SL(2, Z)-semigroup generated by mats, whose elements all have infinite order and nonnegative entries. The growth rate is of the form c*N^nu, and we estimate this by computing the orbit of the column vector in [binsize*Nbins, 2*binsize*Nbins], putting the sizes of the vectors into bins, and then running a linear regression. The return value is [c, nu, R^2], where R^2 is the R^2 value of the regression. The larger this value, the more confidence we have in (c, nu).");
  install(semigroupmats,"GL");
  addhelp(semigroupmats,"semigroupmats(mats, N): assume the matrices in mats all have positive entries and infinite order. This returns the matrices in the semigroup they generate that have all entries at most N. If there are relations, the corresponding matrices will get counted multiple times.");

  /*SECTION 2: MISSING NUMBERS IN ORBITS*/
  install(semigroup_missing,"GGGGL");
  addhelp(semigroup_missing,"semigroup_missing(mats, B, start, congs, entry): prints to a file missing entries in a semigroup orbit. mats is the vector of matrices that generate the semigroup, necessarily all containing nonnegative entries. B is the bounds we wish to search, either a positive integer (for 1 to B), or a vector of two integers. Note that we stop once any entry in the orbit is > B, which means that for some choices of matrices, some entries near B are declared missing but are not actually, as the first time they appear they appear with a larger entry. start is the starting vector for the orbit, consisting of nonnegative numbers. congs=[[r1, r2, ..., rk], modulus] is supplied as the congruence restictions: the entryth entry of a vector is the element we track, and the user must supply the possible congruence classes it can fall into. In this case, that is ri modulo modulus.");
  install(semigroup_missing_parabolic,"GGGGL");
  addhelp(semigroup_missing_parabolic,"semigroup_missing_parabolic(mats, B, start, congs, entry): same as semigroup_missing, except up to 80% slower but uses less memory. If one of the matrices is parabolic, the memory savings is extreme, and it is suggested to use this method when B gets large (10^9 or so). This method will work when none of the matrices are parabolic, though it is unlikely that the difference in memory will matter, and using semigroup_missing is suggested.");
  install(semigroup_missinglist,"iGGGL");
  addhelp(semigroup_missinglist,"semigroup_missinglist(mats, miss, start, entry): this returns 1 if the sorted vector of positive integers miss is entirely missed by the semigroup orbit of <mats>*start, where we look at the entryth entry of the orbit vectors. Calling this on a vector of square numbers gives evidence towards this being missing from an orbit. This is not optimized for parabolic generators, so should not be used for vectors miss which go past 10^9.");

  /*SECTION 3: LINEAR REGRESSION*/
  install(OLS,"GGD1,L,");
  addhelp(OLS,"OLS(X, y, {retrsqr=1}): performs ordinary least squares regression on the data, with the inputs being the n columns of the matrix X, and the outputs being the entries of the column vector y. We include a constant term, so the first row of X must be all 1's. If retrsqr=1, returns [params, R^2], and otherwise returns params, where params is the column vector of best fit parameters.");
  install(OLS_nointercept,"GGD1,L,");
  addhelp(OLS_nointercept,"OLS_nointercept(x, y, {retrsqr=1}): performs ordinary least squares regression assuming that y[i]=c*X[i] (where X and y are both (column) vectors), i.e. the y-intercept is 0. Returns c if retrsqr=0, or [c, R^2] otherwise.");
  install(OLS_single,"GGD1,L,");
  addhelp(OLS_single,"OLS_single(x, y, {retrsqr=1}): performs linear regression for a single variable (essentially a macro for OLS with y=mx+b). Requires y to be a column vector and x is either a vector or column vector.");
  install(rsquared,"GGG");
  addhelp(rsquared,"rsquared(X, y, fit): returns the R^2 value for the proposed linear regression, where the input is X, output is y, and fit is the proposed parameters.");

/*paper.gp*/
  addhelp(testkronaction,"testkronaction(B, n, xymin, xymax): tests Proposition 3.2 by calling kronactioncorrect on n random matrices in SL(2, Z)^{>=0} with entries bounded by B. The values of x, y tried are all valid pairs with xymin<=x, y<=xymax. If the formula fails, we print the failing inputs, and raise an error. If no error occurs, all tests passed successfully.");
  addhelp(kronactioncorrect,"kronactioncorrect(M, x, y): tests Proposition 3.2: M=[a, b;c, d] in SL(2, Z)^{>=0} a, b, c, d >= 0, x, y>=0 coprime, gcd(x, d)=1, this proposition gives a formula for kron(ax+by/cx+dy). This function returns 1 if and only if the formula is correct for the given inputs. If the method returns anything other than 1, then the formula has failed.");

read("paper.gp");
default(parisize, "4096M");\\Must come at the end